---
title: "A very ggplot2 Christmas"
output: html_document
---

About a month ago, [this classic gem](http://is-r.tumblr.com/post/36277968787/happy-thanksgiving-from-isr) popped up in my Twitter feed. For those unable to view the image, it is a Thanksgiving turkey made completely in ggplot2 made by the guys over at [is.R](http://is-r.tumblr.com/). I was so inspired by this plot I decided to see whether I could similarly draw a Christmas tree using only ggplot2:

For those of you who want to jump straight to the final product, [here]() is the code you'll need to reproduce the chart below.



For those who want more of a step-by-step guide, I'll talk you through how I built up each layer of the picture.

## Your base tree

In order to make the base tree, I followed pretty much the [same approach](https://gist.github.com/cdesante/0ab7a6076c0cd0993cc0ae0eb3ecd2fc#file-turkey2016-r) used by the guys at is.R to create their turkey plot. If you have a look at their gist, you can see they created a dataframe which contained all of the parts of the turkey image assigned to different parts of the plot grid. Given that I'm not really all that artistic, I found [an image](https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcSw0w-1TOPluH3LzKgtgqCbmp16eZx8W6SIIiE01QxJL7m3GaaE) of a Christmas tree that I could similarly adapt. I've also used the same code is.R used to create their plot to plot the basic tree.

```{r}
ChristmasTree <- read.csv("https://raw.githubusercontent.com/t-redactyl/Blog-posts/master/Christmas%20tree%20base%20data.csv")

library(ggplot2)

tree <- ggplot() + 
          geom_tile(data = ChristmasTree, aes(x = Tree.X, y = Tree.Y, fill = Tree.Colour)) +       
          scale_fill_identity() + 
          theme_bw() +
          scale_x_continuous(breaks = NULL) + 
          scale_y_continuous(breaks = NULL) +
          labs(x = "", y = "")
tree
```

`geom_tile()` plots each datapoint as a solid square. They then added some formatting options: `theme_bw()` changes the background colour to white; `scale_x_continuous(breaks = NULL)` (and it's y-axis counterpart) get rid of the tickmarks and gridlines; and `labs(x = "", y = "")` gets rid of the axis labels.

## Hanging some lights

Let's now add some lights to the tree! I've done this by overlaying a scatterplot on top of our base tile plot. In order to get a kind of natural looking distribution, I randomly generated x and y coordinates for each of the lights (drawing from a uniform distribution). However, given that the tree is a triangle, I needed to make sure that the lights were not generated **outside** the tree.

To do this, I divided the area of the tree into 6 different rectangles, and generated coordinates for the lights within each of these blocks. However, you can see that each of these occupies a different amount of area (e.g., the bottom block is much larger than the top block). In order to make sure the lights were evenly distributed across the tree, I worked out what proportion of the total area each of these rectangles roughly makes up, and used this as a multiple of the total number of lights I wanted. So for example, the bottom block makes up about 35% of the total area, versus 5% for the top block. So if I wanted 50 lights in total, I'd generate 18 lights for the bottom of the tree, and 3 for the top.

Now we have the placement of the lights sorted, let's get them to twinkle! To do this, I generated a third randomly generated variable with values from 1 to 4. We'll use this to control the transparency of each of the dots.

```{r}
Desired.Lights <- 50
Total.Lights <- sum(round(Desired.Lights * 0.35) + round(Desired.Lights * 0.20) + 
                      round(Desired.Lights * 0.17) + round(Desired.Lights * 0.13) +
                      round(Desired.Lights * 0.10) + round(Desired.Lights * 0.05))

Lights <- data.frame(Lights.X = c(round(runif(round(Desired.Lights * 0.35), 4, 18), 0),
                                       round(runif(round(Desired.Lights * 0.20), 5, 17), 0),
                                       round(runif(round(Desired.Lights * 0.17), 6, 16), 0),
                                       round(runif(round(Desired.Lights * 0.13), 7, 15), 0),
                                       round(runif(round(Desired.Lights * 0.10), 8, 14), 0),
                                       round(runif(round(Desired.Lights * 0.05), 10, 12), 0)))
Lights$Lights.Y <- c(round(runif(round(Desired.Lights * 0.35), 4, 6), 0),
                          round(runif(round(Desired.Lights * 0.20), 7, 8), 0),
                          round(runif(round(Desired.Lights * 0.17), 9, 10), 0),
                          round(runif(round(Desired.Lights * 0.13), 11, 12), 0),
                          round(runif(round(Desired.Lights * 0.10), 13, 14), 0),
                          round(runif(round(Desired.Lights * 0.05), 15, 17), 0))
Lights$Lights.Colour <- c(round(runif(Total.Lights, 1, 4), 0))
```

We now add the lights to our tree by assigning it to a `geom_point()` command. We let ggplot2 know that the base colour of our lights is "lightgoldenrodyellow" by assigning it to the colour argument (make sure you assign it the colour argument outside aes, as these are two different commands!), and that we want to alter the transparency of the dots by assigning Lights.Colour to the `alpha` argument (this time inside aes). 

We also suppress the legend that has just been created by adding `theme(legend.position = "none")`.

```{r}
tree <- tree +
          geom_point(data = Lights, aes(x = Lights.X, y = Lights.Y, alpha = Lights.Colour),
                     colour = "lightgoldenrodyellow", shape = 16) +
          theme(legend.position = "none")
tree
```

Look at that tree sparkle!

## Adding the baubles

Let's now hang some baubles. To do this, we add yet another scatterplot (this time a weighted scatterplot, one of my favourite plot types) on top of our two existing plots. I found the random approach didn't work so well with these, so I manually plotted the coordinates of each of these, as well as manually creating a variable to

## Decorating the presents


## Writing a greeting


